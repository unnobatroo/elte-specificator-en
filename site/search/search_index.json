{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Using the Specificator tool The Specificator tool helps validate data against formal specifications. This guide outlines the steps for using the tool and provides an example structure. Quick start guide Enter the specification: Define your formal specification in the main editor panel. Define the data: In the right-hand panel, press Ctrl+Space to generate a base data structure, then enter your test data. Validation result: If the test case turns green , the data has satisfied the specification. This result validates the correctness of the specification for that input. Debugging: Use the \"Evaluate\" button to display the step-by-step evaluation. This is useful for debugging, though it only works in simpler cases. Example specification (readable formatting) This example checks if a student record ( s ) exists within an array of student records ( students ). In: n\u2208N, students\u2208Student[1..n], Student=(name:S x grade:[1..5]), s\u2208Student Out: found\u2208L Pre: - Post: found = \u2203index\u2208[1..n]: (students[index].name = s.name)","title":"Home"},{"location":"#using-the-specificator-tool","text":"The Specificator tool helps validate data against formal specifications. This guide outlines the steps for using the tool and provides an example structure.","title":"Using the Specificator tool"},{"location":"#quick-start-guide","text":"Enter the specification: Define your formal specification in the main editor panel. Define the data: In the right-hand panel, press Ctrl+Space to generate a base data structure, then enter your test data. Validation result: If the test case turns green , the data has satisfied the specification. This result validates the correctness of the specification for that input. Debugging: Use the \"Evaluate\" button to display the step-by-step evaluation. This is useful for debugging, though it only works in simpler cases.","title":"Quick start guide"},{"location":"#example-specification-readable-formatting","text":"This example checks if a student record ( s ) exists within an array of student records ( students ). In: n\u2208N, students\u2208Student[1..n], Student=(name:S x grade:[1..5]), s\u2208Student Out: found\u2208L Pre: - Post: found = \u2203index\u2208[1..n]: (students[index].name = s.name)","title":"Example specification (readable formatting)"},{"location":"how-to-input-data/","text":"How to input data The Specificator tool accepts data in various formats (JSON-like and YAML-like) that must precisely match the structure defined in your formal specification. 1. Array of Records (e.g., Student Data) The main data structure often involves an array of records (objects), such as a students array, where each object holds defined keys (e.g., name and grade ). JSON/List Format Example This format uses square brackets and commas, common in JSON structures. students: [ {name: \"\u00c1lmos\", grade: 3}, {name: \"Gy\u0151z\u0151\", grade: 5}, {name: \"G\u00e9za\", grade: 4}, ] YAML/Block Format Example This format uses clear indentation and dashes, which can be more readable for complex or lengthy data sets. students: - name: Gy\u0151z\u0151 grade: 5 - name: \u00c1lmos grade: 3 - name: G\u00e9za grade: 2 2. Single Object and Elementary Values Data for single variables is defined directly under the variable name. Single Student Object (s) The variable s (for student ) represents a single object, defining a name and a grade for one entry. YAML Format: s: name: Gy\u0151z\u0151 grade: 5 JSON Format: s: {name: \"Gy\u0151z\u0151\", grade:5} Logical (Boolean) Value A simple example defining a logical variable. included: true","title":"How to input data"},{"location":"how-to-input-data/#how-to-input-data","text":"The Specificator tool accepts data in various formats (JSON-like and YAML-like) that must precisely match the structure defined in your formal specification.","title":"How to input data"},{"location":"how-to-input-data/#1-array-of-records-eg-student-data","text":"The main data structure often involves an array of records (objects), such as a students array, where each object holds defined keys (e.g., name and grade ).","title":"1. Array of Records (e.g., Student Data)"},{"location":"how-to-input-data/#jsonlist-format-example","text":"This format uses square brackets and commas, common in JSON structures. students: [ {name: \"\u00c1lmos\", grade: 3}, {name: \"Gy\u0151z\u0151\", grade: 5}, {name: \"G\u00e9za\", grade: 4}, ]","title":"JSON/List Format Example"},{"location":"how-to-input-data/#yamlblock-format-example","text":"This format uses clear indentation and dashes, which can be more readable for complex or lengthy data sets. students: - name: Gy\u0151z\u0151 grade: 5 - name: \u00c1lmos grade: 3 - name: G\u00e9za grade: 2","title":"YAML/Block Format Example"},{"location":"how-to-input-data/#2-single-object-and-elementary-values","text":"Data for single variables is defined directly under the variable name.","title":"2. Single Object and Elementary Values"},{"location":"how-to-input-data/#single-student-object-s","text":"The variable s (for student ) represents a single object, defining a name and a grade for one entry. YAML Format: s: name: Gy\u0151z\u0151 grade: 5 JSON Format: s: {name: \"Gy\u0151z\u0151\", grade:5} Logical (Boolean) Value A simple example defining a logical variable. included: true","title":"Single Student Object (s)"},{"location":"how-to-write-a-specification/","text":"How to write a specification A formal specification defines the relationship between input In: and output Out: , constrained by pre-conditions Pre: and guaranteed by post-conditions Post: . Input declaration In: Declarations follow the simple pattern: data_name \\(\\in\\) Set. Data names should start with a lowercase letter , and declarations are separated by commas. Elementary sets Notation Example Declaration Set Name Description \\(\\mathbb{N}\\) a\u2208N or a2 eleme N Natural numbers Non-negative integers: \\(\\{0, 1, 2, \\dots\\}\\) \\(\\mathbb{Z}\\) b\u2208Z Integers All positive and negative whole numbers. \\(\\mathbb{R}\\) c\u2208R Real numbers All rational and irrational numbers. \\(\\mathbb{L}\\) d\u2208L Logical (Boolean) values True or False . \\(\\mathbb{S}\\) e\u2208S Strings Sequences of characters. \\(\\mathbb{C}\\) or \\(\\mathbb{K}\\) f\u2208C or f2\u2208K Characters Single characters. Intervals and ranges Description Example The value of iv1 must be an integer between 1 and 3, inclusive. iv1\u2208[1..3] Indexed sequences and arrays Description Notation Indexing/Length An array of 3 natural numbers . x1\u2208N[1..3] Index range 1..3 . (Element referencing: e.g., x1[2] ). The array size n is part of the input, and the array x is composed of integers. n\u2208N, x\u2208Z[1..n] Indexed from 1 to n . An array of natural numbers of some unknown length. x3\u2208N[1..] Indexed starting from 1 . The actual length is determined by the input data. 2. Post-conditions Post: Post-conditions use logical and mathematical expressions to define what must be true after the operation is complete. Logical quantifiers Keywords Example Description \\(\\forall\\) (forall) \u2200i\u2208[1..5]:(i>0) For all \\(i\\) in the set \\([1..5]\\) , the statement is true. \\(\\exists\\) (exists) \u2203i\u2208[1..3]: (i=2) There exists an \\(i\\) in the set \\([1..3]\\) such that the statement is true. Array and matrix operations Operation Formula Description All elements (Universal Quantifier) \u2200i\u2208[1..n]: (x[i] > 10) Used to assert a property holds for every element in a sequence or array. At least one element (Existential Quantifier) \u2203i\u2208[1..n]: (x[i] < 3) Used to assert that a property holds for one or more elements in a sequence or array. Length function ( len ) \u2203i\u2208[1..len(x3)]:(x3[i]<3) Dynamically determines the size of an array \\(\\text{x3}\\) (where the length is not fixed) for quantification. Nested Quantifier (Matrix) \u2200i\u2208[1..8]:(\u2203j\u2208[1..8]:(m1[i,j]=10)) Used for two-dimensional structures (matrices) where a property is checked across rows and columns. Structuring data Data Structure Example Description Records (structs) r1.name=\"Victor\" \u2227 r1.grade=5 Fields are referenced using dot notation. (The symbol \\(\\land\\) is logical AND). Tuples (3,5).1=3 \u2227 (3,5).2=5 Elements are referenced by their number (1-indexed). Array Equality [1, 2, 3]=[1, 2, 3] Checks if two arrays are identical.","title":"How to write a specification"},{"location":"how-to-write-a-specification/#how-to-write-a-specification","text":"A formal specification defines the relationship between input In: and output Out: , constrained by pre-conditions Pre: and guaranteed by post-conditions Post: .","title":"How to write a specification"},{"location":"how-to-write-a-specification/#input-declaration-in","text":"Declarations follow the simple pattern: data_name \\(\\in\\) Set. Data names should start with a lowercase letter , and declarations are separated by commas.","title":"Input declaration In:"},{"location":"how-to-write-a-specification/#elementary-sets","text":"Notation Example Declaration Set Name Description \\(\\mathbb{N}\\) a\u2208N or a2 eleme N Natural numbers Non-negative integers: \\(\\{0, 1, 2, \\dots\\}\\) \\(\\mathbb{Z}\\) b\u2208Z Integers All positive and negative whole numbers. \\(\\mathbb{R}\\) c\u2208R Real numbers All rational and irrational numbers. \\(\\mathbb{L}\\) d\u2208L Logical (Boolean) values True or False . \\(\\mathbb{S}\\) e\u2208S Strings Sequences of characters. \\(\\mathbb{C}\\) or \\(\\mathbb{K}\\) f\u2208C or f2\u2208K Characters Single characters.","title":"Elementary sets"},{"location":"how-to-write-a-specification/#intervals-and-ranges","text":"Description Example The value of iv1 must be an integer between 1 and 3, inclusive. iv1\u2208[1..3]","title":"Intervals and ranges"},{"location":"how-to-write-a-specification/#indexed-sequences-and-arrays","text":"Description Notation Indexing/Length An array of 3 natural numbers . x1\u2208N[1..3] Index range 1..3 . (Element referencing: e.g., x1[2] ). The array size n is part of the input, and the array x is composed of integers. n\u2208N, x\u2208Z[1..n] Indexed from 1 to n . An array of natural numbers of some unknown length. x3\u2208N[1..] Indexed starting from 1 . The actual length is determined by the input data.","title":"Indexed sequences and arrays"},{"location":"how-to-write-a-specification/#2-post-conditions-post","text":"Post-conditions use logical and mathematical expressions to define what must be true after the operation is complete.","title":"2. Post-conditions Post:"},{"location":"how-to-write-a-specification/#logical-quantifiers","text":"Keywords Example Description \\(\\forall\\) (forall) \u2200i\u2208[1..5]:(i>0) For all \\(i\\) in the set \\([1..5]\\) , the statement is true. \\(\\exists\\) (exists) \u2203i\u2208[1..3]: (i=2) There exists an \\(i\\) in the set \\([1..3]\\) such that the statement is true.","title":"Logical quantifiers"},{"location":"how-to-write-a-specification/#array-and-matrix-operations","text":"Operation Formula Description All elements (Universal Quantifier) \u2200i\u2208[1..n]: (x[i] > 10) Used to assert a property holds for every element in a sequence or array. At least one element (Existential Quantifier) \u2203i\u2208[1..n]: (x[i] < 3) Used to assert that a property holds for one or more elements in a sequence or array. Length function ( len ) \u2203i\u2208[1..len(x3)]:(x3[i]<3) Dynamically determines the size of an array \\(\\text{x3}\\) (where the length is not fixed) for quantification. Nested Quantifier (Matrix) \u2200i\u2208[1..8]:(\u2203j\u2208[1..8]:(m1[i,j]=10)) Used for two-dimensional structures (matrices) where a property is checked across rows and columns.","title":"Array and matrix operations"},{"location":"how-to-write-a-specification/#structuring-data","text":"Data Structure Example Description Records (structs) r1.name=\"Victor\" \u2227 r1.grade=5 Fields are referenced using dot notation. (The symbol \\(\\land\\) is logical AND). Tuples (3,5).1=3 \u2227 (3,5).2=5 Elements are referenced by their number (1-indexed). Array Equality [1, 2, 3]=[1, 2, 3] Checks if two arrays are identical.","title":"Structuring data"},{"location":"poas-cheatsheet/","text":"POA's cheatsheet The counting loop is used when the number of iterations is known in advance (e.g., iterating through an entire array or interval [b..e] . The conditional loop is used when the number of iterations is dependent on a condition being met (e.g., stopping as soon as the element is found, as in Search or Decision). # Pattern Structure Description Underlying Loop Structure 1 Summation s = SUM(i=b..e, f(i)) Calculates the sum s of a function f(i) for all elements \\(i\\) in a given integer interval [b..e] . Counting Loop 2 Counting cnt = COUNT(i=b..e, A(i)) Determines the number of times cnt a condition A(i) is true on the interval [b..e] . Counting Loop 3 Maximum Selection maxind, maxval = MAX(i=b..e, f(i)) Finds the index maxind and maximum value maxval of a function f(i) on a non-empty interval [b..e] . Counting Loop 4 Minimum Selection minind, minval = MIN(i=b..e, f(i)) Finds the index minind and minimum value minval of a function f(i) on a non-empty interval [b..e] . Counting Loop 5 Copy y = COPY(i=b..e, f(i)) Creates a new sequence ( \\(y\\) ) by assigning to every element in the interval [b..e] the value produced by the function f(i) . Counting Loop 6 Multiple Item Selection (MIS) cnt, y = MIS(i=b..e, A(i), f(i)) Collects and lists all the values of f(i) from the interval [b..e] for which the condition A(i) is true. Output includes the count cnt and the list y . Counting Loop 7 Search exists = &exists; i \u2208 [b..e]:(A(i)) Determines if an element exists in the interval [b..e] that satisfies a condition A(i) , and if so, finds the first such point ind . Conditional Loop 8 Decision (Exists) exists = SEARCH(i=b..e, A(i)) Determines whether a condition A(i) is true for at least one element in the interval [b..e] . Result is a single Boolean value exists . Conditional Loop 9 Selection ind = SELECT(i \\ge b, A(i)) Finds the leftmost point ind starting from b where the condition A(i) is true, assuming such a point is guaranteed to exist. Conditional Loop 10 Decision All all = FORALL(i=b..e, A(i)) Determines whether a condition A(i) is true for all points in the interval [b..e] . Result is a single Boolean value all . Conditional Loop 11 Conditional Max/Min Selection exists, ind, val = CONDMAX/MIN(i=b..e, f(i), A(i)) Finds the maximum or minimum value of f(i) on [b..e] , but only among points satisfying A(i) . Output includes a boolean exists . Combined Patterns","title":"POA's cheatsheet"},{"location":"poas-cheatsheet/#poas-cheatsheet","text":"The counting loop is used when the number of iterations is known in advance (e.g., iterating through an entire array or interval [b..e] . The conditional loop is used when the number of iterations is dependent on a condition being met (e.g., stopping as soon as the element is found, as in Search or Decision). # Pattern Structure Description Underlying Loop Structure 1 Summation s = SUM(i=b..e, f(i)) Calculates the sum s of a function f(i) for all elements \\(i\\) in a given integer interval [b..e] . Counting Loop 2 Counting cnt = COUNT(i=b..e, A(i)) Determines the number of times cnt a condition A(i) is true on the interval [b..e] . Counting Loop 3 Maximum Selection maxind, maxval = MAX(i=b..e, f(i)) Finds the index maxind and maximum value maxval of a function f(i) on a non-empty interval [b..e] . Counting Loop 4 Minimum Selection minind, minval = MIN(i=b..e, f(i)) Finds the index minind and minimum value minval of a function f(i) on a non-empty interval [b..e] . Counting Loop 5 Copy y = COPY(i=b..e, f(i)) Creates a new sequence ( \\(y\\) ) by assigning to every element in the interval [b..e] the value produced by the function f(i) . Counting Loop 6 Multiple Item Selection (MIS) cnt, y = MIS(i=b..e, A(i), f(i)) Collects and lists all the values of f(i) from the interval [b..e] for which the condition A(i) is true. Output includes the count cnt and the list y . Counting Loop 7 Search exists = &exists; i \u2208 [b..e]:(A(i)) Determines if an element exists in the interval [b..e] that satisfies a condition A(i) , and if so, finds the first such point ind . Conditional Loop 8 Decision (Exists) exists = SEARCH(i=b..e, A(i)) Determines whether a condition A(i) is true for at least one element in the interval [b..e] . Result is a single Boolean value exists . Conditional Loop 9 Selection ind = SELECT(i \\ge b, A(i)) Finds the leftmost point ind starting from b where the condition A(i) is true, assuming such a point is guaranteed to exist. Conditional Loop 10 Decision All all = FORALL(i=b..e, A(i)) Determines whether a condition A(i) is true for all points in the interval [b..e] . Result is a single Boolean value all . Conditional Loop 11 Conditional Max/Min Selection exists, ind, val = CONDMAX/MIN(i=b..e, f(i), A(i)) Finds the maximum or minimum value of f(i) on [b..e] , but only among points satisfying A(i) . Output includes a boolean exists . Combined Patterns","title":"POA's cheatsheet"}]}