{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Using the Specificator Tool","text":"<p>The Specificator tool helps validate data against formal specifications. This guide outlines the steps for using the tool and provides an example structure.</p>"},{"location":"#quick-start-guide","title":"Quick Start Guide","text":"<ol> <li>Enter the Specification: Define your formal specification in the main editor panel.</li> <li>Define the Data: In the right-hand panel, press Ctrl+Space to generate a base data structure, then enter your test data.</li> <li>Validation Result: If the test case turns green, the data has satisfied the specification.<ul> <li>This result validates the correctness of the specification for that input.</li> </ul> </li> <li>Debugging: Use the \"Evaluate\" button to display the step-by-step evaluation. This is useful for debugging, though it only works in simpler cases.</li> </ol>"},{"location":"#example-specification-readable-formatting","title":"Example Specification (Readable Formatting)","text":"<p>This example checks if a student record (<code>s</code>) exists within an array of student records (<code>students</code>).</p> <pre><code>In:  n\u2208N,\n     students\u2208Student[1..n],  \n     Student=(name:S x grade:[1..5]),  \n     s\u2208Student  \nOut: found\u2208L\nPre: -  \nPost: found = \u2203index\u2208[1..n]: \n      (students[index].name = s.name)\n</code></pre>"},{"location":"how-to-input-data/","title":"How to input data","text":"<p>The Specificator tool accepts data in various formats (JSON-like and YAML-like) that must precisely match the structure defined in your formal specification.</p>"},{"location":"how-to-input-data/#1-array-of-records-eg-student-data","title":"1. Array of Records (e.g., Student Data)","text":"<p>The main data structure often involves an array of records (objects), such as a <code>students</code> array, where each object holds defined keys (e.g., name and grade).</p>"},{"location":"how-to-input-data/#jsonlist-format-example","title":"JSON/List Format Example","text":"<p>This format uses square brackets and commas, common in JSON structures.</p> <pre><code>students: [\n    {name: \"\u00c1lmos\", grade: 3},\n    {name: \"Gy\u0151z\u0151\", grade: 5},\n    {name: \"G\u00e9za\", grade: 4},\n]\n</code></pre>"},{"location":"how-to-input-data/#yamlblock-format-example","title":"YAML/Block Format Example","text":"<p>This format uses clear indentation and dashes, which can be more readable for complex or lengthy data sets.</p> <pre><code>students:\n    - name: Gy\u0151z\u0151\n      grade: 5\n    - name: \u00c1lmos\n      grade: 3\n    - name: G\u00e9za\n      grade: 2\n</code></pre>"},{"location":"how-to-input-data/#2-single-object-and-elementary-values","title":"2. Single Object and Elementary Values","text":"<p>Data for single variables is defined directly under the variable name.</p>"},{"location":"how-to-input-data/#single-student-object-s","title":"Single Student Object (s)","text":"<p>The variable <code>s</code> (for student) represents a single object, defining a name and a grade for one entry.</p> <p>YAML Format:</p> <pre><code>s:\n  name: Gy\u0151z\u0151\n  grade: 5\n</code></pre> <p>JSON Format:</p> <pre><code>s: {name: \"Gy\u0151z\u0151\", grade:5}\n</code></pre> <p>Logical (Boolean) Value</p> <p>A simple example defining a logical variable.</p> <pre><code>included: true\n</code></pre>"},{"location":"how-to-write-a-specification/","title":"How to Write a Specification","text":"<p>A formal specification defines the relationship between input (\\(\\text{In}:\\)) and output (\\(\\text{Out}:\\)), constrained by pre-conditions (\\(\\text{Pre}:\\)) and guaranteed by post-conditions (\\(\\text{Post}:\\)).</p>"},{"location":"how-to-write-a-specification/#input-declaration-in","title":"Input Declaration <code>In:</code>","text":"<p>Declarations follow the simple pattern: data_name \\(\\in\\) Set. Data names should start with a lowercase letter, and declarations are separated by commas.</p>"},{"location":"how-to-write-a-specification/#elementary-sets","title":"Elementary Sets","text":"Notation Set Name Description Example Declaration \\(\\mathbb{N}\\) Natural numbers Non-negative integers: \\(\\{0, 1, 2, \\dots\\}\\) <code>a\u2208N</code> or <code>a2 eleme N</code> \\(\\mathbb{Z}\\) Integers All positive and negative whole numbers. <code>b\u2208Z</code> \\(\\mathbb{R}\\) Real numbers All rational and irrational numbers. <code>c\u2208R</code> \\(\\mathbb{L}\\) Logical (Boolean) values True or False. <code>d\u2208L</code> \\(\\mathbb{S}\\) Strings Sequences of characters. <code>e\u2208S</code> \\(\\mathbb{C}\\) or \\(\\mathbb{K}\\) Characters Single characters. <code>f\u2208C</code> or <code>f2\u2208K</code>"},{"location":"how-to-write-a-specification/#intervals-and-ranges","title":"Intervals and Ranges","text":"Example Description <code>iv1\u2208[1..3]</code> The value of iv1 must be an integer between 1 and 3, inclusive."},{"location":"how-to-write-a-specification/#indexed-sequences-and-arrays","title":"Indexed Sequences and Arrays","text":"<p>These are used for handling many elements of the same type.</p> <ul> <li><code>x1\u2208N[1..3]</code>: An array of 3 natural numbers, with index range 1..3. (Element referencing: e.g., <code>x1[2]</code>).</li> <li><code>n\u2208N, x\u2208Z[1..n]</code>: The array size <code>n</code> is part of the input, and the array <code>x</code> is indexed from <code>1</code> to <code>n</code>.</li> <li><code>x3\u2208N[1..]</code>: An array of natural numbers of some length, indexed from 1. The actual length is determined by the input data.</li> </ul>"},{"location":"how-to-write-a-specification/#2-post-conditions-textpost","title":"2. Post-Conditions (\\(\\text{Post}:\\))","text":"<p>Post-conditions use logical and mathematical expressions to define what must be true after the operation is complete.</p>"},{"location":"how-to-write-a-specification/#logical-quantifiers","title":"Logical Quantifiers","text":"Example Keywords Description <code>\u2200i\u2208[1..5]:(i&gt;0)</code> \\(\\forall\\) (forall) For all \\(i\\) in the set \\([1..5]\\), the statement is true. <code>\u2203i\u2208[1..3]: (i=2)</code> \\(\\exists\\) (exists) There exists an \\(i\\) in the set \\([1..3]\\) such that the statement is true."},{"location":"how-to-write-a-specification/#array-and-matrix-operations","title":"Array and Matrix Operations","text":"<ul> <li>Statement on All Elements: <code>\u2200i\u2208[1..n]: (x[i] &gt; 10)</code></li> <li>Statement on At Least One Element: <code>\u2203i\u2208[1..n]: (x[i] &lt; 3)</code></li> <li>Using Length Function: <code>\u2203i\u2208[1..len(x3)]:(x3[i]&lt;3)</code></li> <li>Nested Quantifier (Matrix Example): <code>\u2200i\u2208[1..8]:(\u2203j\u2208[1..8]:(m1[i,j]=10))</code></li> </ul>"},{"location":"how-to-write-a-specification/#structuring-data","title":"Structuring Data","text":"<ul> <li>Records (Structs): Fields are referenced using dot notation: <code>r1.name=\"Victor\" \u2227 r1.grade=5</code>. (The symbol \\(\\land\\) is logical AND).</li> <li>Tuples: Elements are referenced by their number (1-indexed): <code>(3,5).1=3 \u2227 (3,5).2=5</code>.</li> <li>Array Equality: Checks if two arrays are identical: <code>[1, 2, 3]=[1, 2, 3]</code>.</li> </ul>"},{"location":"poas-cheatsheet/","title":"POA's cheatsheet","text":"<ul> <li>The counting loop is used when the number of iterations is known in advance (e.g., iterating through an entire array or interval <code>[b..e]</code>.</li> <li>The conditional loop is used when the number of iterations is dependent on a condition being met (e.g., stopping as soon as the element is found, as in Search or Decision).</li> </ul> # Pattern Description Structure Underlying Loop Structure 1 Summation Calculates the sum <code>s</code> of a function <code>f(i)</code> for all elements \\(i\\) in a given integer interval <code>[b..e]</code>. <code>s = SUM(i=b..e, f(i))</code> Counting Loop 2 Counting Determines the number of times <code>cnt</code> a condition <code>A(i)</code> is true on the interval <code>[b..e]</code>. <code>cnt = COUNT(i=b..e, A(i))</code> Counting Loop 3 Maximum Selection Finds the index <code>maxind</code> and maximum value <code>maxval</code> of a function <code>f(i)</code> on a non-empty interval <code>[b..e]</code>. <code>maxind, maxval = MAX(i=b..e, f(i))</code> Counting Loop 4 Minimum Selection Finds the index <code>minind</code> and minimum value <code>minval</code> of a function <code>f(i)</code> on a non-empty interval <code>[b..e]</code>. <code>minind, minval = MIN(i=b..e, f(i))</code> Counting Loop 5 Copy Creates a new sequence (\\(y\\)) by assigning to every element in the interval <code>[b..e]</code> the value produced by the function <code>f(i)</code>. <code>y = COPY(i=b..e, f(i))</code> Counting Loop 6 Multiple Item Selection (MIS) Collects and lists all the values of <code>f(i)</code> from the interval <code>[b..e]</code> for which the condition <code>A(i)</code> is true. Output includes the count <code>cnt</code> and the list <code>y</code>. <code>cnt, y = MIS(i=b..e, A(i), f(i))</code> Counting Loop 7 Search Determines if an element exists in the interval <code>[b..e]</code> that satisfies a condition <code>A(i)</code>, and if so, finds the first such point <code>ind</code>. <code>exists = &amp;exists; i \u2208 [b..e]:(A(i))</code> Conditional Loop 8 Decision (Exists) Determines whether a condition <code>A(i)</code> is true for at least one element in the interval <code>[b..e]</code>. Result is a single Boolean value <code>exists</code>. <code>exists = SEARCH(i=b..e, A(i))</code> Conditional Loop 9 Selection Finds the leftmost point <code>ind</code> starting from <code>b</code> where the condition <code>A(i)</code> is true, assuming such a point is guaranteed to exist. <code>ind = SELECT(i \\ge b, A(i))</code> Conditional Loop 10 Decision All Determines whether a condition <code>A(i)</code> is true for all points in the interval <code>[b..e]</code>. Result is a single Boolean value <code>all</code>. <code>all = FORALL(i=b..e, A(i))</code> Conditional Loop 11 Conditional Max/Min Selection Finds the maximum or minimum value of <code>f(i)</code> on <code>[b..e]</code>, but only among points satisfying <code>A(i)</code>. Output includes a boolean <code>exists</code>. <code>exists, ind, val = CONDMAX/MIN(i=b..e, f(i), A(i))</code> Combined Patterns"}]}