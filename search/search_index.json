{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Using the Specificator tool Enter the specification. In the right panel, press Ctrl+Space to get a base structure. Enter the data. If the test case turns green, then: The data satisfied the specification; or vice versa. The data validated the correctness of the specification. With the \"Evaluate\" button, the evaluation can also be displayed step-by-step. (Unfortunately, it only works in simpler cases, but it's good for debugging.) Example Specification In:n\u2208N, students\u2208Student[1..n], Student=(name:S x grade:[1..5]), s\u2208Student Out: found\u2208L Pre: - Post: found = \u2203 index \u2208 [1..n]:(students[index].name = s.name)","title":"Home"},{"location":"#using-the-specificator-tool","text":"Enter the specification. In the right panel, press Ctrl+Space to get a base structure. Enter the data. If the test case turns green, then: The data satisfied the specification; or vice versa. The data validated the correctness of the specification. With the \"Evaluate\" button, the evaluation can also be displayed step-by-step. (Unfortunately, it only works in simpler cases, but it's good for debugging.)","title":"Using the Specificator tool"},{"location":"#example-specification","text":"In:n\u2208N, students\u2208Student[1..n], Student=(name:S x grade:[1..5]), s\u2208Student Out: found\u2208L Pre: - Post: found = \u2203 index \u2208 [1..n]:(students[index].name = s.name)","title":"Example Specification"},{"location":"how-to-input-data/","text":"How to input data Student Data Specification The main data is represented by the students array, which holds objects for individual students. Each student object uses the keys name and grade . JSON-like Format List-based declaration for the student data. students: [ {name: \"\u00c1lmos\", grade: 3}, {name: \"Gy\u0151z\u0151\", grade: 5}, {name: \"G\u00e9za\", grade: 4}, ] YAML-like Format Structure the same data using a more traditional YAML block format. students: - name: Gy\u0151z\u0151 grade: 5 - name: \u00c1lmos grade: 3 - name: G\u00e9za grade: 2 Single Student Object The variable s (for student ) represents a single object, defining a name and a grade for one entry. YAML Format Definition for the single student object. s: name: Gy\u0151z\u0151 grade: 5 JSON Format Equivalent structure shown in a JSON format. s: {name: \"Gy\u0151z\u0151\", grade:5} Boolean Value A simple logical (Boolean) variable that is set to true. included: true","title":"How to input data"},{"location":"how-to-input-data/#how-to-input-data","text":"","title":"How to input data"},{"location":"how-to-input-data/#student-data-specification","text":"The main data is represented by the students array, which holds objects for individual students. Each student object uses the keys name and grade .","title":"Student Data Specification"},{"location":"how-to-input-data/#json-like-format","text":"List-based declaration for the student data. students: [ {name: \"\u00c1lmos\", grade: 3}, {name: \"Gy\u0151z\u0151\", grade: 5}, {name: \"G\u00e9za\", grade: 4}, ]","title":"JSON-like Format"},{"location":"how-to-input-data/#yaml-like-format","text":"Structure the same data using a more traditional YAML block format. students: - name: Gy\u0151z\u0151 grade: 5 - name: \u00c1lmos grade: 3 - name: G\u00e9za grade: 2","title":"YAML-like Format"},{"location":"how-to-input-data/#single-student-object","text":"The variable s (for student ) represents a single object, defining a name and a grade for one entry.","title":"Single Student Object"},{"location":"how-to-input-data/#yaml-format","text":"Definition for the single student object. s: name: Gy\u0151z\u0151 grade: 5","title":"YAML Format"},{"location":"how-to-input-data/#json-format","text":"Equivalent structure shown in a JSON format. s: {name: \"Gy\u0151z\u0151\", grade:5}","title":"JSON Format"},{"location":"how-to-input-data/#boolean-value","text":"A simple logical (Boolean) variable that is set to true. included: true","title":"Boolean Value"},{"location":"how-to-write-a-specification/","text":"How to write a specification Input In: Elementary Sets Declaration: data_name\u2208Set . data_name starts with a lowercase letter. Declarations are separated by commas. a\u2208N - Set of Natural numbers, \"a\" is ONE value from the natural numbers. a2 element of N can also be used. b\u2208Z - Set of Integers. c\u2208R - Set of Real numbers. d\u2208L - Set of Logical (boolean) values. e\u2208S - Set of Strings. f\u2208C , f2\u2208K - Set of Characters. Intervals iv1\u2208[1..3] - iv1 's value can be between 1 and 3 (inclusive). Indexed Sequences, Arrays Used for handling many elements of the same type. x1\u2208N[1..3] - Array of 3 natural numbers, with index range 1..3. Note: x1 is one element from the set of all possible 3-element sequences of natural numbers with a 1..3 index range. (Later, referencing an array element: e.g., x1[2] ). x2\u2208N[-1..1] - Array of 3 natural numbers, with index range -1..1. n\u2208N, x\u2208Z[1..n] - Often, the array size is part of the input. x3\u2208N[1..] - Array of natural numbers of some length, indexed from 1. Its actual length is determined by the specific input and can be queried later with length(x3) . x4\u2208N[0..] - Same as above, but indexed from 0. x5\u2208N[] - Abbreviation, equivalent to x5\u2208N[1..] . x6\u2208N[]=[5, 1, 2] - Array with initial value (constant array). x7\u2208N[2+3..n*2] - The index range bounds can be simple expressions. Matrices m1\u2208Z[1..8,1..8] - 8x8 matrix. (Reference: e.g., m1[3,6] ). m2\u2208Z[1..n,1..n] - nxn matrix. m3\u2208Z[0..,0..] - Matrix of some size, indexed from 0. The size is determined from the data. m4\u2208Z[,] - Equivalent to m4\u2208Z[1..,1..] . m5\u2208Z[-1..1,-1..1] = [ [2, 1, 2], [1, 0, 1], [2, 1, 1] ] - Matrix with initial value. Records (Structs, Objects) Used for enclosing different types of values into a single unit. r1\u2208name:S x grade:N - A unit of a string ( name ) and a natural number ( grade ). Note: r1 takes one value from the Cartesian product set S x N . (Later, parts of the record can be referenced by field name: e.g., r1.name ). r2\u2208(name:S x grade:N) - Sets after \u2208 can be parenthesized. r3\u2208(north:L x east:L x south:L x west:L) - A more complex example. r4\u2208(m1:[1..2] x m2:[3..4]) - r4 will be one pair from the set {(1,3), (1,4), (2,3), (2,4)} . Custom Set Names (Types) You can give any existing set another name. Format: Set1=Set2 . Custom set names start with a capital letter. g\u2208Grade, Grade=[1..5] - Grade is a custom name for the interval [1..5] . g2\u2208Mark, Mark=OneToFive, OneToFive=[1..5] - Long chains of renaming are possible. s2\u2208Student[1..], Student=(name:S x grade:N) - Used for clearer descriptions. This is more readable than s1\u2208(name:S x grade:N)[1..] . s3\u2208StudentArray, StudentArray=Student2[], Student2=(name:S x grades:Grade[]) - Example where a student can have multiple grades ( Grade defined above). jaggedArray\u2208Row[], Row=N[] - An array of variable-length arrays (jagged array). Auxiliary Data Aux: Sometimes, intermediate auxiliary data is used to specify the output. These are defined here. aux\u2208N - Same comma-separated declaration format as for the input. Output Out: out\u2208L - Same comma-separated declaration format as for the input. y\u2208N[] Function Definitions Fn: Custom functions can be defined by specifying the domain, codomain, and mapping rule. Fn: f:N->N, f(p)=p*2 A function f that maps a Natural number to a Natural number. f(p) returns p*2 (doubler function). Fn: square:Z->N, square(n)=n*n A function with a descriptive name ( square ). Fn: add:Z x Z->Z, add(a,b)=a+b A function with multiple input parameters. (Note: spaces are needed before and after x ). Fn: swap:Z x Z->Z x Z, swap(a, b)=(b, a) A function that returns a tuple ( swap ). Fn: f2:Z -> Z, f2(p)=p+n Functions have access to declared variables (like n ), unless a parameter shadows the name. Fn: getGrade:Student->N, getGrade(s)=s.grade A function that takes a Record as a parameter. Fn: index:N[] x N->N, index(x,i)=x[i] A function that takes an Array as a parameter. Preconditions Pre: The precondition is a logical expression concerning the input data. The program is only meaningful to execute if this expression is true . It uses standard logical ( and , or , not ), comparison ( = , < , > ), and first-order logic ( \u2200 - forall, \u2203 - exists) operators. true - The simplest precondition (can also be written as Pre: - ). not false n>0 - We can reference data declared in the input. (3<4 or ((3)>4)) - Arbitrary nesting of parentheses. (true -> true) - Implication, which is only false if true implies false . not(true -> false) - This is not(false) , which is true . \u2200i\u2208[1..3]:(i>0) - For all i in the set [1..3] , the statement (i>0) is true. (The keyword forall can also be used). \u2200i\u2208[1..n]:(x[i]>10) - A statement about all elements in an array. \u2203i\u2208[1..3]:(i=2) - There exists an i in the set [1..3] such that the statement (i=2) is true. (The keyword exists can also be used). \u2203i\u2208[1..n]:(x[i]<3) - States that at least one element in array x is less than 3. \u2203i\u2208[1..length(x3)]:(x3[i]<3) - Using the length() function if the array's end index wasn't declared. \u2203i\u2208[from(x3)..to(x3)]:(x3[i]<3) - Index range can also be queried with from() and to() . \u2200i\u2208[1..8]:(\u2203j\u2208[1..8]:(m1[i,j]=10)) - A nested example for a matrix: \"For every row i , there exists a column j such that the element m1[i,j] is 10.\" r1.name=\"Victor\" and r1.grade=5 - Referencing fields in a record. (3, 5).1=3 and (3, 5).2=5 - Tuples can be used and elements are referenced by number. [1, 2, 3]=[1, 2, 3] - Array literals (rare). [0..:1, 2, 3]=[0..:1, 2, 3] - Array literal with an index range. [[1, 2], [3, 4]]=[1..,1..:[1, 2], [3, 4]] - Matrix literal with an index range. Postconditions Post: The postcondition is the most important part of the specification. It is a logical statement that describes the relationship between the input and output data . It is true if, for a valid input (one that satisfies the Pre: ), the program produces the correct output. true - (The description is omitted here as it wouldn't be meaningful without a specific problem).","title":"How to write a specification"},{"location":"how-to-write-a-specification/#how-to-write-a-specification","text":"","title":"How to write a specification"},{"location":"how-to-write-a-specification/#input-in","text":"","title":"Input In:"},{"location":"how-to-write-a-specification/#elementary-sets","text":"Declaration: data_name\u2208Set . data_name starts with a lowercase letter. Declarations are separated by commas. a\u2208N - Set of Natural numbers, \"a\" is ONE value from the natural numbers. a2 element of N can also be used. b\u2208Z - Set of Integers. c\u2208R - Set of Real numbers. d\u2208L - Set of Logical (boolean) values. e\u2208S - Set of Strings. f\u2208C , f2\u2208K - Set of Characters.","title":"Elementary Sets"},{"location":"how-to-write-a-specification/#intervals","text":"iv1\u2208[1..3] - iv1 's value can be between 1 and 3 (inclusive).","title":"Intervals"},{"location":"how-to-write-a-specification/#indexed-sequences-arrays","text":"Used for handling many elements of the same type. x1\u2208N[1..3] - Array of 3 natural numbers, with index range 1..3. Note: x1 is one element from the set of all possible 3-element sequences of natural numbers with a 1..3 index range. (Later, referencing an array element: e.g., x1[2] ). x2\u2208N[-1..1] - Array of 3 natural numbers, with index range -1..1. n\u2208N, x\u2208Z[1..n] - Often, the array size is part of the input. x3\u2208N[1..] - Array of natural numbers of some length, indexed from 1. Its actual length is determined by the specific input and can be queried later with length(x3) . x4\u2208N[0..] - Same as above, but indexed from 0. x5\u2208N[] - Abbreviation, equivalent to x5\u2208N[1..] . x6\u2208N[]=[5, 1, 2] - Array with initial value (constant array). x7\u2208N[2+3..n*2] - The index range bounds can be simple expressions.","title":"Indexed Sequences, Arrays"},{"location":"how-to-write-a-specification/#matrices","text":"m1\u2208Z[1..8,1..8] - 8x8 matrix. (Reference: e.g., m1[3,6] ). m2\u2208Z[1..n,1..n] - nxn matrix. m3\u2208Z[0..,0..] - Matrix of some size, indexed from 0. The size is determined from the data. m4\u2208Z[,] - Equivalent to m4\u2208Z[1..,1..] . m5\u2208Z[-1..1,-1..1] = [ [2, 1, 2], [1, 0, 1], [2, 1, 1] ] - Matrix with initial value.","title":"Matrices"},{"location":"how-to-write-a-specification/#records-structs-objects","text":"Used for enclosing different types of values into a single unit. r1\u2208name:S x grade:N - A unit of a string ( name ) and a natural number ( grade ). Note: r1 takes one value from the Cartesian product set S x N . (Later, parts of the record can be referenced by field name: e.g., r1.name ). r2\u2208(name:S x grade:N) - Sets after \u2208 can be parenthesized. r3\u2208(north:L x east:L x south:L x west:L) - A more complex example. r4\u2208(m1:[1..2] x m2:[3..4]) - r4 will be one pair from the set {(1,3), (1,4), (2,3), (2,4)} .","title":"Records (Structs, Objects)"},{"location":"how-to-write-a-specification/#custom-set-names-types","text":"You can give any existing set another name. Format: Set1=Set2 . Custom set names start with a capital letter. g\u2208Grade, Grade=[1..5] - Grade is a custom name for the interval [1..5] . g2\u2208Mark, Mark=OneToFive, OneToFive=[1..5] - Long chains of renaming are possible. s2\u2208Student[1..], Student=(name:S x grade:N) - Used for clearer descriptions. This is more readable than s1\u2208(name:S x grade:N)[1..] . s3\u2208StudentArray, StudentArray=Student2[], Student2=(name:S x grades:Grade[]) - Example where a student can have multiple grades ( Grade defined above). jaggedArray\u2208Row[], Row=N[] - An array of variable-length arrays (jagged array).","title":"Custom Set Names (Types)"},{"location":"how-to-write-a-specification/#auxiliary-data-aux","text":"Sometimes, intermediate auxiliary data is used to specify the output. These are defined here. aux\u2208N - Same comma-separated declaration format as for the input.","title":"Auxiliary Data Aux:"},{"location":"how-to-write-a-specification/#output-out","text":"out\u2208L - Same comma-separated declaration format as for the input. y\u2208N[]","title":"Output Out:"},{"location":"how-to-write-a-specification/#function-definitions-fn","text":"Custom functions can be defined by specifying the domain, codomain, and mapping rule. Fn: f:N->N, f(p)=p*2 A function f that maps a Natural number to a Natural number. f(p) returns p*2 (doubler function). Fn: square:Z->N, square(n)=n*n A function with a descriptive name ( square ). Fn: add:Z x Z->Z, add(a,b)=a+b A function with multiple input parameters. (Note: spaces are needed before and after x ). Fn: swap:Z x Z->Z x Z, swap(a, b)=(b, a) A function that returns a tuple ( swap ). Fn: f2:Z -> Z, f2(p)=p+n Functions have access to declared variables (like n ), unless a parameter shadows the name. Fn: getGrade:Student->N, getGrade(s)=s.grade A function that takes a Record as a parameter. Fn: index:N[] x N->N, index(x,i)=x[i] A function that takes an Array as a parameter.","title":"Function Definitions Fn:"},{"location":"how-to-write-a-specification/#preconditions-pre","text":"The precondition is a logical expression concerning the input data. The program is only meaningful to execute if this expression is true . It uses standard logical ( and , or , not ), comparison ( = , < , > ), and first-order logic ( \u2200 - forall, \u2203 - exists) operators. true - The simplest precondition (can also be written as Pre: - ). not false n>0 - We can reference data declared in the input. (3<4 or ((3)>4)) - Arbitrary nesting of parentheses. (true -> true) - Implication, which is only false if true implies false . not(true -> false) - This is not(false) , which is true . \u2200i\u2208[1..3]:(i>0) - For all i in the set [1..3] , the statement (i>0) is true. (The keyword forall can also be used). \u2200i\u2208[1..n]:(x[i]>10) - A statement about all elements in an array. \u2203i\u2208[1..3]:(i=2) - There exists an i in the set [1..3] such that the statement (i=2) is true. (The keyword exists can also be used). \u2203i\u2208[1..n]:(x[i]<3) - States that at least one element in array x is less than 3. \u2203i\u2208[1..length(x3)]:(x3[i]<3) - Using the length() function if the array's end index wasn't declared. \u2203i\u2208[from(x3)..to(x3)]:(x3[i]<3) - Index range can also be queried with from() and to() . \u2200i\u2208[1..8]:(\u2203j\u2208[1..8]:(m1[i,j]=10)) - A nested example for a matrix: \"For every row i , there exists a column j such that the element m1[i,j] is 10.\" r1.name=\"Victor\" and r1.grade=5 - Referencing fields in a record. (3, 5).1=3 and (3, 5).2=5 - Tuples can be used and elements are referenced by number. [1, 2, 3]=[1, 2, 3] - Array literals (rare). [0..:1, 2, 3]=[0..:1, 2, 3] - Array literal with an index range. [[1, 2], [3, 4]]=[1..,1..:[1, 2], [3, 4]] - Matrix literal with an index range.","title":"Preconditions Pre:"},{"location":"how-to-write-a-specification/#postconditions-post","text":"The postcondition is the most important part of the specification. It is a logical statement that describes the relationship between the input and output data . It is true if, for a valid input (one that satisfies the Pre: ), the program produces the correct output. true - (The description is omitted here as it wouldn't be meaningful without a specific problem).","title":"Postconditions Post:"}]}